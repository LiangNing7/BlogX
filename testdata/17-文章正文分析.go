package main

import (
	"fmt"

	"github.com/LiangNing7/BlogX/core"
	"github.com/LiangNing7/BlogX/flags"
	"github.com/LiangNing7/BlogX/global"
	"github.com/LiangNing7/BlogX/service/ai_service"
)

func main() {
	flags.Parse()
	global.Config = core.ReadConf()
	core.InitLogrus()

	// msg, err := ai_service.Chat("## 目录结构\n\n大致目录结构如下\n\n```Go\napi              存放api的\nconf             配置文件的结构体映射\ncore             初始化加载的\nflags            绑定命令行参数的\nglobal           全局变量\nmodels           表结构\nrouters          路由\n.gitignore       git忽略文件\ngo.mod\nmain.go          主入口\nsettings.yaml    配置文件\n```\n\n\n\n## git初始化\n\n在做项目的时候，一定要记得使用git去管理你的项目\n\n勤提交，万一电脑出问题了，项目还能继续写，不至于从头开始\n\n\n\n### git忽略文件\n\n最好是先建立这个忽略文件，再进行git init\n\n```YAML\n.idea\nlocal_settings.yaml\ntmp\nmain\nlogs\n```\n\n\n\n## 根据环境读取不同配置文件\n\n之前讲gvb的时候，直接读取的是settings.yaml文件\n\n导致讲邮箱登录、qq登录、七牛云的时候，不敢把配置文件点开\n\n其实完全可以准备两个配置文件，然后以命令行参数的形式指定读取哪一个配置文件\n\n例如\n\n```Go\ngo run main.go -e dev   // 读取local_settings.yaml文件\ngo run main.go -e prod   // 读取settings.yaml文件\n\n```\n\n这样的话，settings.yaml我就可以直接点开给你们看，你们也知道配置参数怎么去填\n\n\n\n### yaml格式\n\n已经遇到太多，配置文件读取失败的用户来问我了\n\n现在编辑器都很智能了，如果你的格式没问题，那么key是高亮的\n\n![](https://image.fengfengzhidao.com/rj_0731/20240809093316.png)\n\n基本的一些配置文件的格式还是要知道的\n\n例如 yaml、json、ini文件\n\n\n\n\n\n### 实现\n\n配置结构体\n\n后续要添加新的配置，就在这里加字段\n\n```Go\n// conf/enter.go\npackage conf\n\ntype Config struct {\n  Mysql Mysql `yaml:\"mysql\"`\n}\n\n```\n\n\n\nglobal全局变量\n\n```Go\n// global/global.go\npackage global\n\nimport (\n  \"fai_server/conf\"\n  \"gorm.io/gorm\"\n)\n\nvar (\n  Config *conf.Config\n  DB     *gorm.DB\n)\n\n```\n\n\n\n绑定命令行参数\n\n```Go\n// flags/enter.go\npackage flags\n\nimport \"flag\"\n\ntype OptionsModel struct {\n  Env string // 环境\n  DB  bool   // 数据库迁移\n}\n\nvar Options OptionsModel\n\nfunc Parse() {\n  flag.StringVar(&Options.Env, \"e\", \"prod\", \"环境\")\n  flag.BoolVar(&Options.DB, \"db\", false, \"数据库迁移\")\n  flag.Parse()\n}\n\nfunc Run() bool {\n  if Options.DB {\n    AutoMigrate()\n    return true\n  }\n  return false\n}\n\n```\n\n\n\n读取配置文件\n\n```Go\n// core/init_yaml.go\npackage core\n\nimport (\n  \"fai_server/conf\"\n  \"fai_server/flags\"\n  \"fmt\"\n  \"gopkg.in/yaml.v2\"\n  \"os\"\n)\n\nfunc InitYaml() (c *conf.Config) {\n  var fileName string\n  switch flags.Options.Env {\n  case \"prod\":\n    fileName = \"settings.yaml\"\n  case \"dev\":\n    fileName = \"local_settings.yaml\"\n  }\n  byteData, err := os.ReadFile(fileName)\n  if err != nil {\n    panic(fmt.Sprintf(\"%s 文件读取失败  %s\", fileName, err))\n  }\n\n  err = yaml.Unmarshal(byteData, &c)\n  if err != nil {\n    panic(fmt.Sprintf(\"yaml解析失败  %s\", err))\n  }\n\n  fmt.Printf(\"配置文件读取成功， 当前环境 %s\\n\", flags.Options.Env)\n  return\n}\n\n```\n\n\n\n## 数据库连接\n\n```Go\n// core/init_gorm.go\npackage core\n\nimport (\n  \"fai_server/global\"\n  \"gorm.io/driver/mysql\"\n  \"gorm.io/gorm\"\n)\n\nfunc InitGorm() *gorm.DB {\n  db, err := gorm.Open(mysql.Open(global.Config.Mysql.Dsn()), &gorm.Config{\n    DisableForeignKeyConstraintWhenMigrating: true,\n  })\n  if err != nil {\n    panic(\"连接数据库失败, \" + err.Error())\n  }\n  // 如果mysql连不上，需不需要重连，需要重连多少次\n  return db\n}\n\n```\n\n\n\n\n\n## 日志初始化\n\n配置结构体\n\n```Go\n// conf/conf_logrus.go\npackage conf\n\ntype Logrus struct {\n  Dir     string `yaml:\"dir\"`\n  AppName string `yaml:\"app_name\"`\n}\n\n```\n\n\n\n```Go\n// core/init_logrus.go\npackage core\n\nimport (\n  \"bytes\"\n  \"fai_server/global\"\n  \"fmt\"\n  \"github.com/sirupsen/logrus\"\n  \"os\"\n  \"path\"\n  \"time\"\n)\n\n// 颜色\nconst (\n  red    = 31\n  yellow = 33\n  blue   = 36\n  gray   = 37\n)\n\ntype LogFormatter struct{}\n\n// Format 实现Formatter(entry *logrus.Entry) ([]byte, error)接口\nfunc (t *LogFormatter) Format(entry *logrus.Entry) ([]byte, error) {\n  //根据不同的level去展示颜色\n  var levelColor int\n  switch entry.Level {\n  case logrus.DebugLevel, logrus.TraceLevel:\n    levelColor = gray\n  case logrus.WarnLevel:\n    levelColor = yellow\n  case logrus.ErrorLevel, logrus.FatalLevel, logrus.PanicLevel:\n    levelColor = red\n  default:\n    levelColor = blue\n  }\n  var b *bytes.Buffer\n  if entry.Buffer != nil {\n    b = entry.Buffer\n  } else {\n    b = &bytes.Buffer{}\n  }\n  //自定义日期格式\n  timestamp := entry.Time.Format(\"2006-01-02 15:04:05\")\n  if entry.HasCaller() {\n    //自定义文件路径\n    funcVal := entry.Caller.Function\n    fileVal := fmt.Sprintf(\"%s:%d\", path.Base(entry.Caller.File), entry.Caller.Line)\n    //自定义输出格式\n    fmt.Fprintf(b, \"[%s] \\x1b[%dm[%s]\\x1b[0m %s %s %s\\n\", timestamp, levelColor, entry.Level, fileVal, funcVal, entry.Message)\n  } else {\n    fmt.Fprintf(b, \"[%s] \\x1b[%dm[%s]\\x1b[0m %s\\n\", timestamp, levelColor, entry.Level, entry.Message)\n  }\n  return b.Bytes(), nil\n}\n\ntype FileDateHook struct {\n  file     *os.File\n  logPath  string\n  fileDate string //判断日期切换目录\n  appName  string\n}\n\nfunc (hook FileDateHook) Levels() []logrus.Level {\n  return logrus.AllLevels\n}\nfunc (hook FileDateHook) Fire(entry *logrus.Entry) error {\n  timer := entry.Time.Format(\"2006-01-02\")\n  line, _ := entry.String()\n  if hook.fileDate == timer {\n    hook.file.Write([]byte(line))\n    return nil\n  }\n  // 时间不等\n  hook.file.Close()\n  os.MkdirAll(fmt.Sprintf(\"%s/%s\", hook.logPath, timer), os.ModePerm)\n  filename := fmt.Sprintf(\"%s/%s/%s.log\", hook.logPath, timer, hook.appName)\n\n  hook.file, _ = os.OpenFile(filename, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600)\n  hook.fileDate = timer\n  hook.file.Write([]byte(line))\n  return nil\n}\n\nfunc InitFile(logPath, appName string) {\n  fileDate := time.Now().Format(\"2006-01-02\")\n  //创建目录\n  err := os.MkdirAll(fmt.Sprintf(\"%s/%s\", logPath, fileDate), os.ModePerm)\n  if err != nil {\n    logrus.Error(err)\n    return\n  }\n\n  filename := fmt.Sprintf(\"%s/%s/%s.log\", logPath, fileDate, appName)\n  file, err := os.OpenFile(filename, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600)\n  if err != nil {\n    logrus.Error(err)\n    return\n  }\n  fileHook := FileDateHook{file, logPath, fileDate, appName}\n  logrus.AddHook(&fileHook)\n}\n\nfunc InitLogrus() {\n  data := global.Config.Logrus\n  if data.Dir == \"\" {\n    panic(\"日志目录不能为空，请修改settings.yaml\")\n  }\n  if data.AppName == \"\" {\n    panic(\"日志的app_name不能为空，请修改settings.yaml\")\n  }\n\n  InitFile(data.Dir, data.AppName)\n\n  logrus.SetOutput(os.Stdout)          //设置输出类型\n  logrus.SetReportCaller(true)         //开启返回函数名和行号\n  logrus.SetFormatter(&LogFormatter{}) //设置自己定义的Formatter\n  logrus.SetLevel(logrus.DebugLevel)   //设置最低的Level\n}\n\n```\n\n\n\n## mysql重连\n\n配置\n\n```Go\n// conf/conf_mysql.go\npackage conf\n\nimport \"fmt\"\n\ntype Mysql struct {\n  User              string `yaml:\"user\"`\n  Pwd               string `yaml:\"pwd\"`\n  Host              string `yaml:\"host\"`\n  Port              int    `yaml:\"port\"`\n  Db                string `yaml:\"db\"`\n  Timeout           string `yaml:\"timeout\"`\n  ReconnectionTimes int    `yaml:\"reconnection_times\"` // 重连次数\n  ReconnectTime     int    `yaml:\"reconnect_time\"`     //  重连的间隔时间单位秒\n}\n\nfunc (m Mysql) Dsn() string {\n  return fmt.Sprintf(\"%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=True&loc=Local&timeout=%s\",\n    m.User, m.Pwd, m.Host, m.Port, m.Db, m.Timeout)\n}\n\n```\n\n\n\n重连\n\n```Go\n// core/init_gorm.go\npackage core\n\nimport (\n  \"fai_server/global\"\n  \"github.com/sirupsen/logrus\"\n  \"gorm.io/driver/mysql\"\n  \"gorm.io/gorm\"\n  \"time\"\n)\n\nvar errCount = 0\n\nfunc InitGorm() *gorm.DB {\n  db, err := gorm.Open(mysql.Open(global.Config.Mysql.Dsn()), &gorm.Config{\n    DisableForeignKeyConstraintWhenMigrating: true,\n  })\n  if err != nil {\n    errCount++\n    if errCount > global.Config.Mysql.ReconnectionTimes {\n      panic(\"连接数据库失败, \" + err.Error())\n    }\n    logrus.Warn(err.Error())\n    time.Sleep(time.Duration(global.Config.Mysql.ReconnectTime) * time.Second)\n    logrus.Warnf(\"mysql连接失败，尝试第%d次重连\", errCount)\n    return InitGorm()\n  }\n  // 如果mysql连不上，需不需要重连，需要重连多少次\n  logrus.Infof(\"mysql连接成功\")\n  return db\n}\n\n```\n\n\n\n\n\n## 路由搭建\n\n目前这个项目采用的是路由分组的策略\n\n一个路由组一个文件，然后把它放到一个api包里面\n\n入口\n\n```Go\n// routers/enter.go\npackage routers\n\nimport (\n  \"fai_server/global\"\n  \"github.com/gin-gonic/gin\"\n  \"github.com/sirupsen/logrus\"\n)\n\nfunc InitRouters() {\n  gin.SetMode(global.Config.System.Env)\n  router := gin.Default()\n\n  apiRouter := router.Group(\"api\")\n\n  SettingsRouter(apiRouter)\n\n  addr := global.Config.System.Addr()\n  logrus.Infof(\"web服务运行在 %s\", addr)\n\n  router.Run(addr)\n}\n\n```\n\n\n\n具体某一个的Router\n\n```Go\n// routers/setting_router.go\npackage routers\n\nimport (\n  \"fai_server/api\"\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc SettingsRouter(r *gin.RouterGroup) {\n  app := api.ApiApp.SettingsApi\n  r.GET(\"settings\", app.SettingInfoView)\n}\n\n```\n\n\n\napi部分\n\n```Go\n// api/enter.go\npackage api\n\nimport \"fai_server/api/settings_api\"\n\ntype Api struct {\n  SettingsApi settings_api.SettingsApi\n}\n\nvar ApiApp = Api{}\n\n```")
	// fmt.Println(msg, err)

	msgChan, err := ai_service.ChatStream("关于测试的文章")
	if err != nil {
		fmt.Println(err)
		return
	}
	for s := range msgChan {
		fmt.Printf(s)
	}
}
